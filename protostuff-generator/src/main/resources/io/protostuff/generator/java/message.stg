delimiters "<", ">"
import "io/protostuff/generator/core.stg"
import "io/protostuff/generator/java/generator.stg"
import "io/protostuff/generator/java/enum.stg"
import "io/protostuff/generator/java/schema.stg"
import "io/protostuff/generator/java/oneof.stg"

message_compiler_enabled(message) ::= <%
<if(message.nested)>false<else>true<endif>
%>

message_compiler_output(message) ::= "<message.proto.javaPackagePath>/<message.javaName>.java"
message_compiler_template(message) ::= "<message:message()>"

message(message) ::= <<
package <message.proto.javaPackage>;

<message:message_body()>
>>

message_body(message) ::= <<
<if(!message.nested)><message:generator_annotation()><endif>
public <if(message.nested)>static <endif>final class <message.javaName>
        implements io.protostuff.Message\<<message.javaName>\>{

    <message.fields:field_declaration(); separator="\n">
    private boolean __lock = false;
    <message.javaBitFieldNames:message_bit_field(); separator="\n">
    <message.oneofs:oneof_fields(); separator="\n">

    private void initialize() {
        <message.fields:field_initializer(); separator="\n">
    }

    public static <message.javaName> newBuilder() {
        return new <message.javaName>();
    }

    public static io.protostuff.Schema\<<message.javaName>\> getSchema()
    {
    	return Schema.INSTANCE;
    }

    <message.fields:field_accessors(); separator="\n">

    <message.oneofs:oneof_case(); separator="\n">

    public <message.javaName> build() {
        initialize();
        this.__lock = true;
        return this;
    }

    @Override
    public io.protostuff.Schema\<<message.javaName>\> cachedSchema() {
        return Schema.INSTANCE;
    }

    @Override
    public boolean equals(Object obj) {
    	if (this == obj) {
    		return true;
    	}
    	if (obj == null || this.getClass() != obj.getClass()) {
    		return false;
    	}
    	<message.javaName> that = (<message.javaName>) obj;
    	<if(message.hasFields)>
    	<message.fields:field_equals_part()>
    	<message.oneofs:oneof_field_equals_part()>
    	return true;
    	<else>
    	return true;
    	<endif>
    }

    @Override
    public int hashCode() {
    	<if(message.hasFields)>
    	int result = 1;
    	<message.fields:field_hashCode_part()>
        <message.oneofs:oneof_field_hashCode_part()>
    	return result;
    	<else>
    	return 0;
    	<endif>
    }

    @Override
    public String toString() {
        java.util.List\<String> parts = new java.util.ArrayList\<>();
        <message.fields:field_toString_part()>
        return "<message.javaName>{" + String.join(", ", parts) + "}";
    }

    <message:schema()>

    <message.messages:message_body(); separator="\n">
    
    <message.enums:enum_body(); separator="\n">

    <message.oneofs:one_of(); separator="\n">
}
>>

field_equals_part(field) ::= <<
<if(!field.oneofPart)>
if (!java.util.Objects.equals(this.<field.javaName>, that.<field.javaName>)) {
    return false;
}
<endif>
>>

oneof_field_equals_part(oneof) ::= <<
if (!(java.util.Objects.equals(this.<oneof.javaCaseFieldName>, that.<oneof.javaCaseFieldName>)
        && java.util.Objects.equals(this.<oneof.javaFieldName>, that.<oneof.javaFieldName>))) {
    return false;
}
>>

field_hashCode_part(field) ::= <<
<if(!field.oneofPart)>
<if(!field.repeated && (field.javaIsNumericType || field.javaIsBooleanType))>
result = 31 * result + <field.type.javaWrapperType>.hashCode(<field.javaName>);
<else>
result = 31 * result + (<field.javaName> == null ? 0 : <field.javaName>.hashCode());
<endif>
<endif>
>>

oneof_field_hashCode_part(oneof) ::= <<
result = 31 * result + <oneof.javaCaseFieldName>.hashCode();
result = 31 * result + (<oneof.javaFieldName> == null ? 0 : <oneof.javaFieldName>.hashCode());
>>

oneof_case(oneOf) ::= <<
public <oneOf.javaName> <oneOf.javaCaseGetterName>() {
    return <oneOf.javaCaseFieldName>;
}
>>


oneof_fields(oneOf) ::= <<
private <oneOf.javaName> <oneOf.javaCaseFieldName> = <oneOf.javaName>.<oneOf.javaNotSetConstantName>;
private Object <oneOf.javaFieldName> = null;
>>

message_bit_field(name) ::= <<
private int <name>;
>>

field_initializer(field) ::= <<
<if(field.map)>
if (<field.javaName> == null) {
    <field.javaName> = java.util.Collections.emptyMap();
} else {
    <field.javaName> = java.util.Collections.unmodifiableMap(<field.javaName>);
}
<elseif(field.repeated)>
if (<field.javaName> == null) {
    <field.javaName> = java.util.Collections.emptyList();
} else {
    <field.javaName> = java.util.Collections.unmodifiableList(<field.javaName>);
}
<endif>
>>

field_declaration(field) ::= <<
<if(field.map)>
private <field.javaMapType> <field.javaName>;
<elseif(field.repeated)>
private <field.javaRepeatedType> <field.javaName>;
<else>
private <field.javaType> <field.javaName>;
<endif>
>>

field_accessors(field) ::= <<
<if(field.oneofPart)>
public <field.javaType> <field.javaGetterName>() {
    if (<field.oneof.javaCaseFieldName> == <field.oneof.javaName>.<field.javaOneofConstantName>) {
        return (<field.javaType>) <field.oneof.javaFieldName>;
    }
    return <field.javaDefaultValue>;
}

public <field.parent.javaName> <field.javaSetterName>(<field.javaType> value) {
    <field:check_field_modification_lock()>
    <check_field_value_is_not_null(field=field, var="value")>
    this.<field.oneof.javaFieldName> = value;
    this.<field.oneof.javaCaseFieldName> = <field.oneof.javaName>.<field.javaOneofConstantName>;
    return this;
}

public boolean <field.javaHasMethodName>() {
    return <field.oneof.javaCaseFieldName> == <field.oneof.javaName>.<field.javaOneofConstantName>;
}
<elseif(field.map)>
public <field.javaMapType> <field.javaMapGetterName>() {
    return <field.javaName>;
}

public <field.parent.javaName> <field.javaMapSetterName>(<field.javaMapType> map) {
    <field:check_field_modification_lock()>
    if (map == null) {
        throw new NullPointerException("Cannot set <field.parent.javaName>#<field.javaName> to null");
    }
    this.<field.javaName> = map;
    return this;
}

public <field.parent.javaName> <field.javaMapAdderName>(<field.javaMapKeyType> key, <field.javaMapValueType> value) {
    <field:check_field_modification_lock()>
    if (this.<field.javaName> == null) {
        this.<field.javaName> = new java.util.HashMap\<>();
    }
    if (key == null) {
        throw new NullPointerException("Cannot set <field.parent.javaName>#<field.javaName> - map key is null");
    }
    if (value == null) {
        throw new NullPointerException("Cannot set <field.parent.javaName>#<field.javaName> - map value is null");
    }
    this.<field.javaName>.put(key, value);
    return this;
}

public int <field.javaRepeatedGetCountMethodName>() {
    return <field.javaName>.size();
}

public <field.javaMapValueType> <field.javaMapGetByKeyMethodName>(<field.javaMapKeyType> key) {
    return <field.javaName>.get(key);
}
<elseif(field.repeated)>
public <field.javaRepeatedType> <field.javaRepeatedGetterName>() {
    return <field.javaName>;
}

public <field.parent.javaName> <field.javaRepeatedSetterName>(<field.javaRepeatedType> list) {
    <field:check_field_modification_lock()>
    if (list == null) {
        throw new NullPointerException("Cannot set <field.parent.javaName>#<field.javaName> to null");
    }
    this.<field.javaName> = list;
    return this;
}

public <field.parent.javaName> <field.javaRepeatedAdderName>(<field.javaType> value) {
    <field:check_field_modification_lock()>
    <check_field_value_is_not_null(field=field, var="value")>
    if (this.<field.javaName> == null) {
        this.<field.javaName> = new java.util.ArrayList\<>();
    }
    this.<field.javaName>.add(value);
    return this;
}

public <field.parent.javaName> <field.javaRepeatedAdderName>(<field.javaRepeatedType> values) {
    <field:check_field_modification_lock()>
    if (values == null) {
        throw new NullPointerException("Cannot set <field.parent.javaName>#<field.javaName> to null");
    }
    if (this.<field.javaName> == null) {
        this.<field.javaName> = new java.util.ArrayList\<>();
    }
    this.<field.javaName>.addAll(values);
    return this;
}

public int <field.javaRepeatedGetCountMethodName>() {
    return <field.javaName>.size();
}

public <field.javaType> <field.javaRepeatedGetByIndexMethodName>(int index) {
    return <field.javaName>.get(index);
}
<else>
public <field.javaType> <field.javaGetterName>() {
    if ((<field.javaBitFieldName> & <field.javaBitFieldMask>) == 0) {
        return <field.javaDefaultValue>;
    }
    return <field.javaName>;
}

public <field.parent.javaName> <field.javaSetterName>(<field.javaType> value) {
    <field:check_field_modification_lock()>
    <check_field_value_is_not_null(field=field, var="value")>
    this.<field.javaName> = value;
    <field.javaBitFieldName> |= <field.javaBitFieldMask>;
    return this;
}

public boolean <field.javaHasMethodName>() {
    return (<field.javaBitFieldName> & <field.javaBitFieldMask>) == <field.javaBitFieldMask>;
}
<endif>
>>

check_field_modification_lock(field) ::= <<
if(__lock) {
    throw new IllegalStateException("Could not update <field.parent.javaName>.<field.javaName>");
}
>>

check_field_value_is_not_null(field, var) ::= <<
<if(field.type.message || field.type.enum || field.type.scalar && field.javaIsScalarNullableType)>
if (<var> == null) {
    throw new NullPointerException("Cannot set <field.parent.javaName>#<field.javaName> to null");
}
<endif>
>>

field_toString_part(field) ::= <<
<if(field.repeated)>
if (!<field.javaName>.isEmpty()) {
<else>
if (<field.javaHasMethodName>()) {
<endif>
    parts.add(<field.toStringPart>);
}
>>
